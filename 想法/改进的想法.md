# 改进的想法

* 现在集成计算服务是需要手动在整个计算服务提供端添加代码的。
  		① 这种方式的弊端代码量多了之后不好维护，计算端开发者操作复杂。

  ​	    ② 不能够存在两个计算操作（option）之前存在需要的包版本不同

  ​		③ 不能够热插拔，不能够动态的管理

  **解决办法**

  使用微服务注册中心的概念，每个算法是一个单独的服务，每一个单独的服务后期可直接打包为一个单独的docker容器。可写一个admin来进行服务的管理，可动态的配置服务的启用、禁用、删除、添加等。开发者开发完成一个服务之后直接自己在服务器上部署上去或者是直接在admin上提交指定规范的代码包和Dockerfile并输入必要的参数之后服务便可动态集成。

  

* 现在task队列的消费是存到队列里去，每过10s就检测一次队列是否为空，如果队列不为空的话就把task队列里面的任务全部拿出来执行

  ​	   ① 消耗资源，没过10s就要检测一下，而且容易出问题。

  ​	   ② 后期如果要多个实例机器同时处理task的话这种队列的方式就会出现问题。

  **解决办法** 

  使用mq消息队列的方式进行task队列的存储，有task封装完成就直接把task发送到队列里。消息接收端接收到数据之后就开始处理。

  并且mq的queue还实现了负载均衡，一个生产者可以对应多个消费者。  拟采用rabbitmq

  （后面如果http方式并不是很好的话 服务调用可采用rabbitmq。具体实现方式还没看）

  ![Image](https://img-blog.csdn.net/20170816171523564?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvb01hdmVyaWNrMQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)



* 节点动态装配，类似于分布式的东西，每一台服务器上都有全部的节点容器（docker） 只有需要使用到这个节点的时候才会把这些节点运行起来，这样的话每一台服务器都可以运行全部的节点，并且不会存在运行的节点过多但不用出现盲目占用内存的情况

  * 在Java端可以维护一个服务器集群，某一个task或者是某几个task（选取一个or几个task的算法暂时没想）需要在服务器上运行的时候Java再动态的ssh到服务器上

    * 加载or存储相应的文件（或者是手动copy，暂时没想具体实现）

    * 启动需要调用的option（一个option是一个容器，一个web服务）

    * 启动完成之后进行计算

    * 计算完成并返回结果之后关闭所有容器

      **暂时性改进的想法，没做过，不知道这么做难不难**

      

* 现在参数是直接存到内存里面，传参数是直接通过http的方式传给python端的。在这种情况下会出现数据量太大数据的传输成本问题

  **解决办法**

  调度段获取到参数之后把参数存到文件当中去，在计算端调用的时候传文件的原数据过去，计算端获取到原数据之后直接在文件上进行操作。

  * 计算端做一个类似于aop的东西，做一个装饰器，读取文件和文件的保存参数的更新都直接提前封装好，计算模块的开发者只需要关注自身计算代码的开发
  * **这个的实现得等到实现数据动态加载的时候再来做，因为现在本身就是读的内存里面的数据，等到时候需要读文件的数据的时候再统一对数据进行封装并保存到文件当中去**

* 

* 

* 

  

  

  

  

  

  

  

  

  

  

